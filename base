#!/usr/bin/env python3
import socketserver
from time import ctime
import socket
import sys
from termios import tcflush, TCIFLUSH
import threading
import json

lock = threading.Lock()
ID_CLIENT = []
ID_list = []
current_client = []
max_client_count = 3 
allclient_connect = 0
allclient_press5 = 0

finish_client = 0

class MyRequestHandler(socketserver.BaseRequestHandler):
    def setup(self):
        global current_client, allclient_connect, allclient_press5, lock, ID_CLIENT
        thread_id = threading.currentThread().getName().split("-")[1]
        lock.acquire()
        ID_list.append(thread_id)
        current_client.append(self.request)
        lock.release()
        print('a user connect, IP:',self.client_address)
        print("This thread id",thread_id)
        if len(current_client) >= max_client_count: # only one client will enter this IF condition
            tcflush(sys.stdin, TCIFLUSH)  # clean the input queue, try to avoid type 'enter' beforehead
            print(ID_list,current_client)
            signal = input("All users are connected. Wait for signal (type any key and \"enter\" or \"enter\" only): ")
            message = "press 5 to continue"
            for s in current_client:
                s.sendall(bytes(message,"utf-8"))
            print("wait for clients to answer...")
            ID_CLIENT = current_client.copy()
            current_client.clear()
            allclient_connect = 1

        while True: # Some client need to wait here for other clients connect to server
            if allclient_connect == 1:
                break

        client_press_5 = self.request.recv(1024).strip().decode()
        current_client.append(self.request)

        if len(current_client) >= max_client_count:
            tcflush(sys.stdin, TCIFLUSH)  # clean the input queue, try to avoid type 'enter' beforehead
            message = "Start the game!"
            for s,i in zip(ID_CLIENT,ID_list):
                s.sendall(bytes(i,"utf-8"))
            current_client.clear()
            allclient_press5 = 1
        
        while True:
            if allclient_press5 == 1:
                break
            
         
    def handle(self):
        global finish_client
        # print('connect from ', self.client_address)
        # cur_trd = threading.current_thread()
        print("Server request info:",self.request)        
        
        while True:
            data = None;
            data = self.request.recv(1024).strip().decode()
            if not data:  # If client disconnect data will be None
                break
            else:
                print("client say:", data)
                self.request.sendall(('[%s] %s' % (ctime(), data)).encode())
                client_finish = self.request.recv(1024).strip().decode()
                print("after client finish:", client_finish)
                current_client.append(self.request)
                finish_client += 1

            if len(current_client) >= max_client_count:
                for s in current_client:
                    s.sendall("can go to next trail!".encode())
                current_client.clear()
                finish_client = 0

            while True:
                if finish_client == 0:
                    break

        '''
        while True:
            data = self.request.recv(1024)
            if not data:
                break
            else:
                jdata = json.loads(data)
                print(type(data))
                print(type(jdata))
                print("jdata:",jdata[0])
                self.request.sendall(('[%s]' % ctime()).encode())
        '''
        self.request.close()
    def finish(self):
        print('A user diconnect.')

class ThreadingTCPSserver(socketserver.ThreadingMixIn, socketserver.TCPServer):
    daemon_threads = True        # kill all of the thread when get any exceptions
    allow_reuse_address = True   # avoid some error when reboot the server
    pass

if __name__ == "__main__":
    # HOST, PORT = '127.0.0.1', 10001
    HOST = socket.gethostbyname(socket.gethostname())   # check current IP address
    PORT = 10001
    ADDRESS = (HOST,PORT)
    try:
        with ThreadingTCPSserver(ADDRESS,MyRequestHandler) as server:
            print('waiting for connection')
            server.serve_forever()
    except KeyboardInterrupt:
        print("\ncaught keyboard interrupt, exiting")
        server.shutdown()
        server.server_close()
    except ConnectionResetError:
        print("client already close! can't send!")
