#!/usr/bin/env python3
from stop_view import Ui_MainWindow as Ui_stop
from ui import Ui_MainWindow as Ui_play
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5 import *
import socket
import select
import getch # detect if client press '5', need to install this package
import json
import time
import sys

class MainWindow(QMainWindow):
  def __init__(self, sock, parent=None):
    super(MainWindow, self).__init__(parent)
    self.mode_dic = {'init': 1, 'start':2, 'stop':3, 'alloc':4, 'wait':5}
    self.mode = 1
    self.my_id = 0
    self.other_id = 3
    self.recv_data = 0
    self.sock = sock
    self.timer_stop = QTimer(self)
    self.timer_stop.timeout.connect(self.set_stop_view)
    self.screen = QDesktopWidget().screenGeometry ()
    self.QtStack = QtWidgets.QStackedLayout()
    self.showFullScreen()
    self.Ui_setup()
    self.show()
    self.ConnectToServer(5)
    self.my_id = int(self.recv_data)
    self.set_id(self.my_id)

  def ConnectToServer(self, data):
    self.sock.send(str(data).encode())
    self.recv_data = self.sock.recv(1024).decode()
    print("receive data :" + self.recv_data)

  def Ui_setup(self):
    try:
      self.mode = self.mode_dic['init']
      self.start_view = Ui_play()
      self.start_view.setupUi(self)
      self.stop_view = Ui_stop()
      self.stop_view.setupUi(self)
      self.stop_view.label.setText("Press 5")
      #self.setCentralWidget(self.stop_view.centralwidget)
      self.start_view.centralwidget.resize(self.screen.width(),self.screen.height())
      self.stop_view.centralwidget.resize(self.screen.width(),self.screen.height())
      self.QtStack.addWidget(self.start_view.centralwidget)
      self.QtStack.addWidget(self.stop_view.centralwidget)
      self.QtStack.setCurrentIndex(1)

    except Exception as e:
       print(e)

  def set_start_view(self):
    get_src(self)
    self.mode = self.mode_dic['start']
    self.start_view.alloc_1.setText("")
    self.start_view.alloc_3.setText("")
    self.start_view.alloc_2.setText("")
    self.QtStack.setCurrentIndex(0)

  def set_stop_view(self):
    self.mode = self.mode_dic['stop']
    self.stop_view.label.setText("+")
    self.QtStack.setCurrentIndex(1)

  def set_wait_view(self):
    self.mode = self.mode_dic['wait']
    self.stop_view.label.setText("Wait")
    self.QtStack.setCurrentIndex(1)

  def set_alloc_view(self):
    self.mode = self.mode_dic['alloc']
    self.start_view.alloc_1.setText("5")
    self.start_view.alloc_2.setText("1")
    self.start_view.alloc_3.setText("5")
    self.QtStack.setCurrentIndex(0)

  def keyPressEvent(self, event):
    assert(self.my_id != self.other_id), "my id is the same to other id. "
    key = event.key()
    if key == QtCore.Qt.Key_Escape:
      self.showNormal()
    elif self.mode == self.mode_dic['init'] and key == QtCore.Qt.Key_5:
      self.set_start_view()
    #  self.set_timer(5)
      self.set_alloc_view()
    elif self.mode == self.mode_dic['start']:
      select_id = 0
      if key == QtCore.Qt.Key_2:
        select_id = self.my_id%3 + 1
      elif key == QtCore.Qt.Key_1:
        select_id =  3 if self.my_id-1 == 0 else self.my_id-1
      self.ConnectToServer(select_id)
      self.mode = self.mode_dic['wait']
    elif self.mode == self.mode_dic['alloc'] and key == QtCore.Qt.Key_1:
      self.alloc_src(self.my_id, self.other_id, -1)
    elif self.mode == self.mode_dic['alloc'] and key == QtCore.Qt.Key_2:
      self.alloc_src(self.my_id, self.other_id, 1)

  def set_id(self, my_id):
    # my_id : int
    id = [1, 2 ,3]
    my_id -= 1
    self.start_view.pos_2.setText("ID : " + str(id[my_id]))
    self.start_view.pos_3.setText("ID : " + str(id[(my_id+1)%3]))
    self.start_view.pos_1.setText("ID : " + str(id[(my_id+2)%3]))
    QApplication.processEvents()

  def set_src(self, my_id, src_list):
    # my_id : int, src_list : string list
    my_id -= 1
    self.start_view.src_2.setText(src_list[my_id])
    self.start_view.src_3.setText(src_list[(my_id+1)%3])
    self.start_view.src_1.setText(src_list[(my_id+2)%3])
    QApplication.processEvents()

  def alloc_src(self, my_id, other_id, add_minus):
    my_src = int(self.start_view.alloc_2.text())
    if my_src == 0 and add_minus == -1:
      return
    if my_id%3+1 == other_id:
      other_src = int(self.start_view.alloc_3.text())
      if other_src == 0 and add_minus == 1:
        return
      self.start_view.alloc_3.setText(str(other_src-add_minus))
    else:
      other_src = int(self.start_view.alloc_1.text())
      if other_src == 0 and add_minus == 1:
        return
      self.start_view.alloc_1.setText(str(other_src-add_minus))

    self.start_view.alloc_2.setText(str(my_src+add_minus))
    self.setCentralWidget(self.start_view.centralwidget)

  def set_timer(self, stop_time):
    self.timer_stop.start(stop_time*1000)

#########

def ui_setup(sock):
  app = QApplication(sys.argv)
  window = MainWindow(sock)
  window.show()
  sys.exit(app.exec_())
  return app, window

def get_src(window):
  src = ["5", "5" ,"1"]
  window.set_src(window.my_id, src)

def main():
  msg = [{'src':"yeeeeeeee",'dst':"hahahaha"}]
  jmsg = json.dumps(msg)
  TimeOut = 10

  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    Host = socket.gethostbyname(socket.gethostname())
    print("Host:",Host)
    sock.connect((Host, 10001))
    print("wait for server...")
    print(sock.recv(1024).decode())
    #while True:

    app, window = ui_setup(sock)
    get_src(window)

    while True:
      print("> ", end='', flush=True)
      inputStart = time.time()
      i, o, e = select.select( [sys.stdin], [], [], TimeOut )
      if i:
        inputEnd = time.time()
        print("you spend ", inputEnd - inputStart, " second on input")
        data = sys.stdin.readline().strip()
        if data == "":
          break

        sock.send(data.encode())
        print (sock.recv(1024).decode())
        sock.send("finish one transit".encode())
        print (sock.recv(1024).decode())
      else:
        print("\nYou miss one trail!")
        data = "One client miss a trail!"
        sock.send(data.encode())
        print(sock.recv(1024).decode())
        sock.send("all clients jump to the next trail".encode())
        print(sock.recv(1024).decode())

    sock.close()

if __name__ == "__main__":
  main()
