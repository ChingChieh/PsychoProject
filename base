#!/usr/bin/env python3
import socketserver
from time import ctime
import socket
import sys
from termios import tcflush, TCIFLUSH
import threading
import json

current_client = []
max_client_count = 3 
allclient_connect = 0
allclient_press5 = 0

class MyRequestHandler(socketserver.BaseRequestHandler):
    def setup(self):
        global current_client, allclient_connect, allclient_press5
        current_client.append(self.request)
        print('a user connect, IP:',self.client_address)
        if len(current_client) >= max_client_count:
            tcflush(sys.stdin, TCIFLUSH)  # clean the input queue, try to avoid type 'enter' beforehead
            signal = input("All users are connected. Wait for signal (type any key and \"enter\" or \"enter\" only): ")
            message = "press 5 to continue"
            for s in current_client:
                s.sendall(bytes(message,"utf-8"))
            print("wait for clients to answer...")
            current_client.clear()
            allclient_connect = 1

        while True:
            if allclient_connect == 1:
                break

        client_press_5 = self.request.recv(1024).strip().decode()
        current_client.append(self.request)

        if len(current_client) >= max_client_count:
            tcflush(sys.stdin, TCIFLUSH)  # clean the input queue, try to avoid type 'enter' beforehead
            message = "Start the game!"
            for s in current_client:
                s.sendall(bytes(message,"utf-8"))
            current_client.clear()
            allclient_press5 = 1
        
        while True:
            if allclient_press5 == 1:
                break
            
         
    def handle(self):
        # print('connect from ', self.client_address)
        # cur_trd = threading.current_thread()
        print("Server request info:",self.request)        
        while True:
            data = self.request.recv(1024).strip().decode()
            if not data:  # If client disconnect data will be None
                break
            else:
                print("client say:", data)
                self.request.sendall(('[%s] %s' % (ctime(), data)).encode())
        '''
        while True:
            data = self.request.recv(1024)
            if not data:
                break
            else:
                jdata = json.loads(data)
                print(type(data))
                print(type(jdata))
                print("jdata:",jdata[0])
                self.request.sendall(('[%s]' % ctime()).encode())
        '''
        self.request.close()
    def finish(self):
        print('A user diconnect.')

class ThreadingTCPSserver(socketserver.ThreadingMixIn, socketserver.TCPServer):
    daemon_threads = True        # kill all of the thread when get any exceptions
    allow_reuse_address = True   # avoid some error when reboot the server
    pass

if __name__ == "__main__":
    # HOST, PORT = '127.0.0.1', 10001
    HOST = socket.gethostbyname(socket.gethostname())   # check current IP address
    PORT = 10001
    ADDRESS = (HOST,PORT)
    try:
        with ThreadingTCPSserver(ADDRESS,MyRequestHandler) as server:
            print('waiting for connection')
            server.serve_forever()
    except KeyboardInterrupt:
        print("\ncaught keyboard interrupt, exiting")
        server.shutdown()
        server.server_close()
    except ConnectionResetError:
        print("client already close! can't send!")
