#!/usr/bin/env python3
import socketserver
from time import ctime
import socket
# First, you must create a request handler class by subclassing the BaseRequestHandler class 
# and overriding its handle() method
class MyRequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        print('connect form ', self.client_address)
        '''
        while True: 
            data = self.request.recv(1024).strip().decode()
            if data:
                print(data)
                self.request.sendall(('[%s] %s' % (ctime(), data)).encode())
            else:
                break
        '''
        while True:
            data = self.request.recv(1024).strip()
            if not data:  # If client disconnect data will be None
                break
            else:
                print("client say:", data)
                self.request.sendall(('[%s] %s' % (ctime(), data)).encode())
            
        #self.request.close()
    def finish(self):
        print('A user diconnect.')

class ThreadingTCPSserver(socketserver.ThreadingMixIn, socketserver.TCPServer):
    daemon_threads = True
    allow_reuse_address = True
    pass


# with socketserver.TCPServer((HOST, PORT), MyTCPHandler) as server:
if __name__ == "__main__":
    # HOST, PORT = '127.0.0.1', 10001
    HOST = socket.gethostbyname(socket.gethostname())
    PORT = 10001
    ADDRESS = (HOST,PORT)
    try:
        # Second, you must instantiate one of the server classes, 
        # passing it the serverâ€™s address and the request handler class.
        with ThreadingTCPSserver(ADDRESS,MyRequestHandler) as server:
            print('waiting for connection')
            server.serve_forever()
    except KeyboardInterrupt:
        print("\ncaught keyboard interrupt, exiting")
        server.shutdown()
        server.server_close()
    except ConnectionResetError:
        print("client already close! can't send!")
